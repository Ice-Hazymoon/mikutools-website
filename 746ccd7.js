(window.webpackJsonp=window.webpackJsonp||[]).push([[203],{2935:function(t,e,r){"use strict";r.r(e),r.d(e,"FilesystemWeb",(function(){return d}));var o=r(12);function n(path){const t=path.split("/").filter((t=>"."!==t)),e=[];return t.forEach((t=>{".."===t&&e.length>0&&".."!==e[e.length-1]?e.pop():e.push(t)})),e.join("/")}class d extends o.WebPlugin{constructor(){super(...arguments),this.DB_VERSION=1,this.DB_NAME="Disc",this._writeCmds=["add","put","delete"]}async initDb(){if(void 0!==this._db)return this._db;if(!("indexedDB"in window))throw this.unavailable("This browser doesn't support IndexedDB");return new Promise(((t,e)=>{const r=indexedDB.open(this.DB_NAME,this.DB_VERSION);r.onupgradeneeded=d.doUpgrade,r.onsuccess=()=>{this._db=r.result,t(r.result)},r.onerror=()=>e(r.error),r.onblocked=()=>{console.warn("db blocked")}}))}static doUpgrade(t){const e=t.target.result;t.oldVersion;e.objectStoreNames.contains("FileStorage")&&e.deleteObjectStore("FileStorage");e.createObjectStore("FileStorage",{keyPath:"path"}).createIndex("by_folder","folder")}async dbRequest(t,e){const r=-1!==this._writeCmds.indexOf(t)?"readwrite":"readonly";return this.initDb().then((o=>new Promise(((n,d)=>{const c=o.transaction(["FileStorage"],r).objectStore("FileStorage")[t](...e);c.onsuccess=()=>n(c.result),c.onerror=()=>d(c.error)}))))}async dbIndexRequest(t,e,r){const o=-1!==this._writeCmds.indexOf(e)?"readwrite":"readonly";return this.initDb().then((n=>new Promise(((d,c)=>{const h=n.transaction(["FileStorage"],o).objectStore("FileStorage").index(t)[e](...r);h.onsuccess=()=>d(h.result),h.onerror=()=>c(h.error)}))))}getPath(t,e){const r=void 0!==e?e.replace(/^[/]+|[/]+$/g,""):"";let o="";return void 0!==t&&(o+="/"+t),""!==e&&(o+="/"+r),o}async clear(){(await this.initDb()).transaction(["FileStorage"],"readwrite").objectStore("FileStorage").clear()}async readFile(t){const path=this.getPath(t.directory,t.path),e=await this.dbRequest("get",[path]);if(void 0===e)throw Error("File does not exist.");return{data:e.content?e.content:""}}async writeFile(t){const path=this.getPath(t.directory,t.path);let data=t.data;const e=t.encoding,r=t.recursive,o=await this.dbRequest("get",[path]);if(o&&"directory"===o.type)throw Error("The supplied path is a directory.");const n=path.substr(0,path.lastIndexOf("/"));if(void 0===await this.dbRequest("get",[n])){const e=n.indexOf("/",1);if(-1!==e){const o=n.substr(e);await this.mkdir({path:o,directory:t.directory,recursive:r})}}if(!e&&(data=data.indexOf(",")>=0?data.split(",")[1]:data,!this.isBase64String(data)))throw Error("The supplied data is not valid base64 content.");const d=Date.now(),c={path:path,folder:n,type:"file",size:data.length,ctime:d,mtime:d,content:data};return await this.dbRequest("put",[c]),{uri:c.path}}async appendFile(t){const path=this.getPath(t.directory,t.path);let data=t.data;const e=t.encoding,r=path.substr(0,path.lastIndexOf("/")),o=Date.now();let n=o;const d=await this.dbRequest("get",[path]);if(d&&"directory"===d.type)throw Error("The supplied path is a directory.");if(void 0===await this.dbRequest("get",[r])){const e=r.indexOf("/",1);if(-1!==e){const o=r.substr(e);await this.mkdir({path:o,directory:t.directory,recursive:!0})}}if(!e&&!this.isBase64String(data))throw Error("The supplied data is not valid base64 content.");void 0!==d&&(data=void 0===d.content||e?d.content+data:btoa(atob(d.content)+atob(data)),n=d.ctime);const c={path:path,folder:r,type:"file",size:data.length,ctime:n,mtime:o,content:data};await this.dbRequest("put",[c])}async deleteFile(t){const path=this.getPath(t.directory,t.path);if(void 0===await this.dbRequest("get",[path]))throw Error("File does not exist.");if(0!==(await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(path)])).length)throw Error("Folder is not empty.");await this.dbRequest("delete",[path])}async mkdir(t){const path=this.getPath(t.directory,t.path),e=t.recursive,r=path.substr(0,path.lastIndexOf("/")),o=(path.match(/\//g)||[]).length,n=await this.dbRequest("get",[r]),d=await this.dbRequest("get",[path]);if(1===o)throw Error("Cannot create Root directory");if(void 0!==d)throw Error("Current directory does already exist.");if(!e&&2!==o&&void 0===n)throw Error("Parent directory must exist");if(e&&2!==o&&void 0===n){const o=r.substr(r.indexOf("/",1));await this.mkdir({path:o,directory:t.directory,recursive:e})}const c=Date.now(),h={path:path,folder:r,type:"directory",size:0,ctime:c,mtime:c};await this.dbRequest("put",[h])}async rmdir(t){const{path:path,directory:e,recursive:r}=t,o=this.getPath(e,path),n=await this.dbRequest("get",[o]);if(void 0===n)throw Error("Folder does not exist.");if("directory"!==n.type)throw Error("Requested path is not a directory");const d=await this.readdir({path:path,directory:e});if(0!==d.files.length&&!r)throw Error("Folder is not empty");for(const t of d.files){const o=`${path}/${t.name}`;"file"===(await this.stat({path:o,directory:e})).type?await this.deleteFile({path:o,directory:e}):await this.rmdir({path:o,directory:e,recursive:r})}await this.dbRequest("delete",[o])}async readdir(t){const path=this.getPath(t.directory,t.path),e=await this.dbRequest("get",[path]);if(""!==t.path&&void 0===e)throw Error("Folder does not exist.");const r=await this.dbIndexRequest("by_folder","getAllKeys",[IDBKeyRange.only(path)]);return{files:await Promise.all(r.map((async t=>{let e=await this.dbRequest("get",[t]);return void 0===e&&(e=await this.dbRequest("get",[t+"/"])),{name:t.substring(path.length+1),type:e.type,size:e.size,ctime:e.ctime,mtime:e.mtime,uri:e.path}})))}}async getUri(t){const path=this.getPath(t.directory,t.path);let e=await this.dbRequest("get",[path]);return void 0===e&&(e=await this.dbRequest("get",[path+"/"])),{uri:(null==e?void 0:e.path)||path}}async stat(t){const path=this.getPath(t.directory,t.path);let e=await this.dbRequest("get",[path]);if(void 0===e&&(e=await this.dbRequest("get",[path+"/"])),void 0===e)throw Error("Entry does not exist.");return{type:e.type,size:e.size,ctime:e.ctime,mtime:e.mtime,uri:e.path}}async rename(t){await this._copy(t,!0)}async copy(t){return this._copy(t,!1)}async requestPermissions(){return{publicStorage:"granted"}}async checkPermissions(){return{publicStorage:"granted"}}async _copy(t,e=!1){let{toDirectory:r}=t;const{to:o,from:d,directory:c}=t;if(!o||!d)throw Error("Both to and from must be provided");r||(r=c);const h=this.getPath(c,d),l=this.getPath(r,o);if(h===l)return{uri:l};if(function(t,e){t=n(t),e=n(e);const r=t.split("/"),o=e.split("/");return t!==e&&r.every(((t,e)=>t===o[e]))}(h,l))throw Error("To path cannot contain the from path");let y;try{y=await this.stat({path:o,directory:r})}catch(t){const e=o.split("/");e.pop();const n=e.join("/");if(e.length>0){if("directory"!==(await this.stat({path:n,directory:r})).type)throw new Error("Parent directory of the to path is a file")}}if(y&&"directory"===y.type)throw new Error("Cannot overwrite a directory with a file");const w=await this.stat({path:d,directory:c}),f=async(path,t,e)=>{const o=this.getPath(r,path),n=await this.dbRequest("get",[o]);n.ctime=t,n.mtime=e,await this.dbRequest("put",[n])},m=w.ctime?w.ctime:Date.now();switch(w.type){case"file":{const t=await this.readFile({path:d,directory:c});e&&await this.deleteFile({path:d,directory:c});const n=await this.writeFile({path:o,directory:r,data:t.data});return e&&await f(o,m,w.mtime),n}case"directory":{if(y)throw Error("Cannot move a directory over an existing object");try{await this.mkdir({path:o,directory:r,recursive:!1}),e&&await f(o,m,w.mtime)}catch(t){}const t=(await this.readdir({path:d,directory:c})).files;for(const n of t)await this._copy({from:`${d}/${n}`,to:`${o}/${n}`,directory:c,toDirectory:r},e);e&&await this.rmdir({path:d,directory:c})}}return{uri:l}}isBase64String(t){try{return btoa(atob(t))==t}catch(t){return!1}}}d._debug=!0}}]);